# INC Implementation Plan
Disclaimer:
This document is written with assistance of Claude 4.

## Overview

This document outlines the high-level plan for implementing In-Network Computing (INC) support in the EQDS simulator, specifically making `main_eqds.cpp` capable of handling INC-aware traffic patterns generated by `gen_allreduce_inc_ded_pod.py`.

## STeps

1. **Parse INC semantics** from traffic matrix files (`semantics agg_op SUM agg_dir UP fid X rid Y cid Z`)
2. **Track aggregation state** at switches based on `(fid, rid, cid)` keys
3. **Perform in-network aggregation** when packets with matching keys arrive
4. **Create aggregated packets** and multicast them to all worker nodes

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                    Traffic Matrix File                       │
│  (with INC semantics: agg_op, agg_dir, fid, rid, cid)       │
└───────────────────────┬───────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│              ConnectionMatrix Parser                         │
│  - Parse INC semantics from connection lines                │
│  - Store in connection struct                               │
└───────────────────────┬───────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│              main_eqds.cpp Setup                             │
│  - Extract INC metadata from connections                    │
│  - Pass to EqdsSrc/EqdsSink                                 │
└───────────────────────┬───────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│              EqdsSrc Packet Creation                         │
│  - Embed INC metadata in packets                            │
│  - Set agg_op, agg_dir, fid, rid, cid                       │
└───────────────────────┬───────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│              Network Routing                                 │
│  - Packets route normally through network                    │
│  - INC metadata preserved in packet headers                 │
└───────────────────────┬───────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│              FatTreeSwitch INC Processing                    │
│  - Detect INC packets (agg_dir == UP)                       │
│  - Track aggregation state per (fid, rid, cid)              │
│  - Aggregate values when packets arrive                     │
│  - Create new aggregated packets when complete              │
│  - Multicast to all worker destinations                     │
└───────────────────────┬───────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│              Aggregated Packet Delivery                      │
│  - DOWN direction packets route normally                    │
│  - Delivered to all worker nodes                            │
└─────────────────────────────────────────────────────────────┘
```

## Implementation Phases

### Phase 1: Data Structure Extensions

**Goal:** Add INC metadata support to core data structures

#### 1.1 Connection Structure (`connection_matrix.h`)
- **File:** `sim/datacenter/connection_matrix.h`
- **Changes:**
  ```cpp
  struct connection {
      // existing fields
      
      // INC semantics
      uint32_t agg_op;        // AGG_SUM, AGG_MAX, AGG_MIN, etc.
      uint32_t agg_dir;       // UP (gather) or DOWN (scatter)
      uint32_t fid;           // Flow ID for grouping
      uint32_t rid;           // Round/iteration ID
      uint32_t cid;           // Chunk ID
      bool has_inc_semantics; // Flag indicating INC flow
  };
  ```

#### 1.2 Packet Structure (`eqdspacket.h`)
- **File:** `sim/eqdspacket.h`
- **Changes:**
  ```cpp
  class EqdsDataPacket : public EqdsBasePacket {
      // ... existing fields ...
      
      // INC metadata
      uint32_t _agg_op;
      uint32_t _agg_dir;
      uint32_t _inc_fid;
      uint32_t _inc_rid;
      uint32_t _inc_cid;
      bool _has_inc_semantics;
      
      // Accessors
      inline uint32_t agg_op() const { return _agg_op; }
      inline uint32_t agg_dir() const { return _agg_dir; }
      inline uint32_t fid() const { return _inc_fid; }
      inline uint32_t rid() const { return _inc_rid; }
      inline uint32_t cid() const { return _inc_cid; }
      inline bool hasIncSemantics() const { return _has_inc_semantics; }
  };
  ```

#### 1.3 Source/Sink Classes (`eqds.h`)
- **File:** `sim/eqds.h`
- **Changes:**
  ```cpp
  class EqdsSrc {
      // existing fields
      
      // INC metadata storage
      uint32_t _agg_op, _agg_dir, _inc_fid, _inc_rid, _inc_cid;
      bool _has_inc_semantics;
      
      // Methods
      void setIncSemantics(uint32_t op, uint32_t dir, uint32_t fid, 
                          uint32_t rid, uint32_t cid);
  };
  ```

---

### Phase 2: Parser Modifications

**Goal:** Parse INC semantics from traffic matrix files

#### 2.1 Connection Matrix Parser (`connection_matrix.cpp`)
- **File:** `sim/datacenter/connection_matrix.cpp`
- **Location:** `ConnectionMatrix::load()` function, token parsing loop (lines 751-798)
- **Changes:**
  ```cpp
  // In token parsing loop, add:
  else if (tokens[i] == "semantics") {
      c->has_inc_semantics = true;
      i++; // skip "semantics" keyword
      
      // Parse: agg_op SUM agg_dir UP fid 1 rid 1 cid 0
      while (i < tokens.size() && tokens[i] != "send_done_trigger" 
             && tokens[i] != "recv_done_trigger" && tokens[i] != "trigger") {
          if (tokens[i] == "agg_op") {
              i++;
              if (tokens[i] == "SUM") c->agg_op = AGG_SUM;
              else if (tokens[i] == "MAX") c->agg_op = AGG_MAX;
              // ... other operations
          }
          else if (tokens[i] == "agg_dir") {
              i++;
              if (tokens[i] == "UP") c->agg_dir = AGG_DIR_UP;
              else if (tokens[i] == "DOWN") c->agg_dir = AGG_DIR_DOWN;
          }
          else if (tokens[i] == "fid") {
              i++;
              c->fid = stoi(tokens[i]);
          }
          else if (tokens[i] == "rid") {
              i++;
              c->rid = stoi(tokens[i]);
          }
          else if (tokens[i] == "cid") {
              i++;
              c->cid = stoi(tokens[i]);
          }
          i++;
      }
      continue; // Don't treat remaining tokens as errors
  }
  ```

---

### Phase 3: Main Setup Integration

**Goal:** Pass INC metadata from connections to sources/sinks

#### 3.1 Main Setup (`main_eqds.cpp`)
- **File:** `sim/datacenter/main_eqds.cpp`
- **Location:** Connection setup loop (lines 488-578)
- **Changes:**
  ```cpp
  // After line 519 (setFlowsize), add:
  if (crt->has_inc_semantics) {
      eqds_src->setIncSemantics(crt->agg_op, crt->agg_dir, 
                                crt->fid, crt->rid, crt->cid);
      eqds_snk->setIncSemantics(crt->agg_op, crt->agg_dir, 
                                crt->fid, crt->rid, crt->cid);
  }
  ```
- **Impact:** Low - minimal changes to existing flow

---

### Phase 4: Packet Creation with INC Metadata

**Goal:** Embed INC metadata in packets when created

#### 4.1 Source Packet Creation (`eqds.cpp`)
- **File:** `sim/eqds.cpp`
- **Location:** `EqdsSrc::sendNewPacket()` (line 874)
- **Changes:**
  ```cpp
  // Modify EqdsDataPacket::newpkt() call to include INC metadata:
  auto *p = EqdsDataPacket::newpkt(_flow, *_route, _highest_sent, 
                                    full_pkt_size, ptype, _pull_target, 
                                    /*unordered=*/true, _dstaddr,
                                    // Add INC parameters:
                                    _has_inc_semantics ? _agg_op : 0,
                                    _has_inc_semantics ? _agg_dir : 0,
                                    _has_inc_semantics ? _inc_fid : 0,
                                    _has_inc_semantics ? _inc_rid : 0,
                                    _has_inc_semantics ? _inc_cid : 0);
  ```
- **Impact:** Medium - requires updating `newpkt()` signature

#### 4.2 Packet Factory Update (`eqdspacket.h`)
- **File:** `sim/eqdspacket.h`
- **Location:** `EqdsDataPacket::newpkt()` (lines 42-71)
- **Changes:**
  ```cpp
  inline static EqdsDataPacket* newpkt(PacketFlow &flow, const Route &route, 
                                       seq_t epsn, mem_b full_size, 
                                       PacketType pkttype, pull_quanta pull_target, 
                                       bool unordered, uint32_t destination = UINT32_MAX,
                                       // New INC parameters (with defaults):
                                       uint32_t agg_op = 0, uint32_t agg_dir = 0,
                                       uint32_t fid = 0, uint32_t rid = 0, 
                                       uint32_t cid = 0) {
      // ... existing initialization ...
      
      // Set INC metadata
      p->_has_inc_semantics = (agg_op != 0 || agg_dir != 0);
      p->_agg_op = agg_op;
      p->_agg_dir = agg_dir;
      p->_inc_fid = fid;
      p->_inc_rid = rid;
      p->_inc_cid = cid;
      
      return p;
  }
  ```

---

### Phase 5: Switch Aggregation Logic

**Goal:** Implement in-network aggregation at switches

#### 5.1 Aggregation State Structures (`fat_tree_switch.h`)
- **File:** `sim/datacenter/fat_tree_switch.h`
- **Changes:**
  ```cpp
  // Add aggregation key structure
  struct AggregationKey {
      uint32_t fid;
      uint32_t rid;
      uint32_t cid;
      
      bool operator<(const AggregationKey& other) const {
          if (fid != other.fid) return fid < other.fid;
          if (rid != other.rid) return rid < other.rid;
          return cid < other.cid;
      }
  };
  
  // Add aggregation state structure
  struct AggregationState {
      uint32_t expected_count;      // Number of workers (sources)
      uint32_t received_count;      // Packets received so far
      mem_b agg_value;              // Accumulated value
      set<uint32_t> received_sources; // Track which sources contributed
      vector<uint32_t> worker_destinations; // All nodes needing result
      simtime_picosec first_arrival_time;
      simtime_picosec last_arrival_time;
  };
  
  class FatTreeSwitch {
      // ... existing members ...
      
      // INC aggregation state
      map<AggregationKey, AggregationState> _agg_table;
      PacketFlow* _default_agg_flow; // Flow object for aggregated packets
      
      // INC methods
      bool processIncAggregation(Packet& pkt);
      void multicastAggregatedResult(uint32_t fid, uint32_t rid, uint32_t cid);
      mem_b extractPacketValue(Packet& pkt);
      uint32_t getNumWorkersForChunk(uint32_t fid, uint32_t rid, uint32_t cid);
      vector<uint32_t> getWorkerDestinations(uint32_t fid, uint32_t rid, uint32_t cid);
  };
  ```


#### 5.2 Switch Packet Processing (`fat_tree_switch.cpp`)
- **File:** `sim/datacenter/fat_tree_switch.cpp`
- **Location:** `FatTreeSwitch::receivePacket()` (lines 23-58)
- **Changes:**
  ```cpp
  void FatTreeSwitch::receivePacket(Packet& pkt) {
      // ... existing pause handling ...
      
      if (_packets.find(&pkt) == _packets.end()) {
          // INGRESS: Check for INC aggregation
          EqdsDataPacket* eqds_pkt = dynamic_cast<EqdsDataPacket*>(&pkt);
          if (eqds_pkt && eqds_pkt->hasIncSemantics() 
              && eqds_pkt->agg_dir() == AGG_DIR_UP) {
              
              // Process INC aggregation
              bool complete = processIncAggregation(*eqds_pkt);
              
              // Consume original packet
              pkt.free();
              
              if (complete) {
                  // Create and multicast aggregated packets
                  multicastAggregatedResult(eqds_pkt->fid(), 
                                          eqds_pkt->rid(), 
                                          eqds_pkt->cid());
              }
              return; // Original packet consumed, don't forward
          }
          
          // Normal packet processing continues...
          _packets[&pkt] = true;
          const Route* nh = getNextHop(pkt, NULL);
          pkt.set_route(*nh);
          _pipe->receivePacket(pkt);
      } else {
          // EGRESS: Normal forwarding
          _packets.erase(&pkt);
          pkt.sendOn();
      }
  }
  ```

#### 5.3 Aggregation Processing Implementation (`fat_tree_switch.cpp`)
- **File:** `sim/datacenter/fat_tree_switch.cpp`
- **New Functions:**
  ```cpp
  bool FatTreeSwitch::processIncAggregation(Packet& pkt) {
      EqdsDataPacket* eqds_pkt = dynamic_cast<EqdsDataPacket*>(&pkt);
      assert(eqds_pkt);
      
      AggregationKey key = {eqds_pkt->fid(), eqds_pkt->rid(), eqds_pkt->cid()};
      
      // Initialize state if new
      if (_agg_table.find(key) == _agg_table.end()) {
          AggregationState state;
          state.expected_count = getNumWorkersForChunk(key.fid, key.rid, key.cid);
          state.received_count = 0;
          state.agg_value = 0;
          state.worker_destinations = getWorkerDestinations(key.fid, key.rid, key.cid);
          state.first_arrival_time = eventlist().now();
          _agg_table[key] = state;
      }
      
      AggregationState& state = _agg_table[key];
      
      // Extract value from packet
      mem_b pkt_value = extractPacketValue(*eqds_pkt);
      
      // Perform aggregation operation
      switch (eqds_pkt->agg_op()) {
          case AGG_SUM:
              state.agg_value += pkt_value;
              break;
          case AGG_MAX:
              state.agg_value = max(state.agg_value, pkt_value);
              break;
          case AGG_MIN:
              state.agg_value = min(state.agg_value, pkt_value);
              break;
          // ... other operations
      }
      
      state.received_count++;
      state.received_sources.insert(pkt.src());
      state.last_arrival_time = eventlist().now();
      
      // Check if aggregation complete
      return (state.received_count == state.expected_count);
  }
  
  void FatTreeSwitch::multicastAggregatedResult(uint32_t fid, uint32_t rid, uint32_t cid) {
      AggregationKey key = {fid, rid, cid};
      AggregationState& state = _agg_table[key];
      
      // Create aggregated packet for each destination
      for (uint32_t dst : state.worker_destinations) {
          // Get route to destination
          Route* route = getRouteToHost(dst);
          
          // Create new aggregated packet
          EqdsDataPacket* agg_pkt = EqdsDataPacket::newpkt(
              *_default_agg_flow,  // Use default flow for aggregated packets
              *route,
              0,  // Sequence number (not used for aggregated)
              state.agg_value,  // Aggregated value as payload size
              EqdsDataPacket::DATA_PULL,
              0,  // pull_target
              false,  // unordered
              dst,  // destination
              AGG_NONE,  // No more aggregation
              AGG_DIR_DOWN,  // DOWN direction
              fid, rid, cid  // Preserve fid, rid, cid
          );
          
          // Send aggregated packet
          agg_pkt->sendOn();
      }
      
      // Clean up aggregation state
      _agg_table.erase(key);
  }
  
  mem_b FatTreeSwitch::extractPacketValue(Packet& pkt) {
      // Option 1: Use packet payload size as value
      return pkt.size() - EqdsDataPacket::ACKSIZE;
      
      // Option 2: Extract from packet metadata (if implemented)
      // return pkt.getIncValue();
  }
  ```
- **Impact:** High - core aggregation logic

#### 5.4 Helper Functions (`fat_tree_switch.cpp`)
- **File:** `sim/datacenter/fat_tree_switch.cpp`
- **New Functions:**
  ```cpp
  uint32_t FatTreeSwitch::getNumWorkersForChunk(uint32_t fid, uint32_t rid, uint32_t cid) {
      // Option 1: Use topology information
      // Return total nodes - 1 (excluding aggregator)
      return _ft->no_of_nodes() - 1;
      
      // Option 2: Count from connection matrix (requires access)
      // This would need connection matrix passed to switch
  }
  
  vector<uint32_t> FatTreeSwitch::getWorkerDestinations(uint32_t fid, uint32_t rid, uint32_t cid) {
      // Return all nodes except aggregator
      // For dedicated pod: all nodes not in aggregation pod
      vector<uint32_t> workers;
      for (uint32_t i = 0; i < _ft->no_of_nodes(); i++) {
          // Skip aggregator nodes (pod 0 in dedicated pod scenario)
          if (!_ft->isAggregationNode(i)) {
              workers.push_back(i);
          }
      }
      return workers;
  }
  
  Route* FatTreeSwitch::getRouteToHost(uint32_t dst) {
      // Get route from this switch to destination host
      // Implementation depends on switch type (ToR, Agg, Core)
      // This may need topology helper methods
  }
  ```

---

### Phase 6: Topology Helpers

**Goal:** Add methods to identify aggregation nodes and get routes

#### 6.1 Topology Extensions (`fat_tree_topology.h`)
- **File:** `sim/datacenter/fat_tree_topology.h`
- **Changes:**
  ```cpp
  class FatTreeTopology {
      // ... existing members ...
      
      // INC helper methods
      bool isAggregationNode(uint32_t node_id);
      uint32_t getAggregationPod();
      Route* getRouteFromSwitchToHost(FatTreeSwitch* sw, uint32_t dst);
  };
  ```


---

### Phase 7: Constants and Enums

**Goal:** Define INC-related constants

#### 7.1 INC Constants Header
- **File:** New file `sim/datacenter/inc_constants.h` or add to existing header
- **Content:**
  ```cpp
  #ifndef INC_CONSTANTS_H
  #define INC_CONSTANTS_H
  
  // Aggregation operations
  enum AggregationOp {
      AGG_NONE = 0,
      AGG_SUM = 1,
      AGG_MAX = 2,
      AGG_MIN = 3,
      AGG_AVG = 4
  };
  
  // Aggregation direction
  enum AggregationDir {
      AGG_DIR_NONE = 0,
      AGG_DIR_UP = 1,    // Gather phase (toward aggregator)
      AGG_DIR_DOWN = 2   // Scatter phase (from aggregator)
  };
  
  #endif
  ```


---

## Implementation Order

### Recommended Sequence

1. **Phase 1.1-1.3**: Add data structures (connection, packet, source/sink)
   - Low risk, can be done incrementally
   - Test: Compilation, basic packet creation

2. **Phase 7**: Add constants/enums
   - Foundation for other phases
   - Test: Compilation

3. **Phase 2.1**: Modify parser
   - Critical path - needed for loading traffic files
   - Test: Parse sample INC traffic file, verify fields populated

4. **Phase 3.1**: Main setup integration
   - Connect parser output to sources/sinks
   - Test: Verify INC metadata passed correctly

5. **Phase 4.1-4.2**: Packet creation with INC
   - Embed metadata in packets
   - Test: Verify packets contain INC metadata

6. **Phase 6.1**: Topology helpers
   - Support functions for aggregation logic
   - Test: Verify aggregation node identification

7. **Phase 5.1-5.4**: Switch aggregation logic
   - Core INC functionality
   - Test: Unit tests for aggregation, integration tests with traffic

---


## Key Design Decisions

### 1. Where Aggregation Happens
- **Decision:** At switches (not queues or dedicated components)
- **Rationale:** Matches P4 switch model, allows aggregation at any switch level

### 2. Packet Handling
- **Decision:** Use packet payload size as value (initially)
- **Rationale:** Simple, works for current use case
- **Future:** add explicit value field

### 3. Aggregation State Cleanup
- **Decision:** Clean up immediately after multicast

### 6. Flow Object for Aggregated Packets
- **Decision:** Use default/global flow object
- **Rationale:** Aggregated packets don't belong to original flows
- **Alternative:** Create per-aggregation flows

---

## Potential Challenges

### 1. Expected Count Accuracy
- **Problem:** How to know exactly how many packets to expect?
- **Solution:** Use topology info initially, enhance with connection matrix analysis later

### 2. Aggregation at Multiple Switches
- **Problem:** Packets may arrive at different switches
- **Solution:** Each switch maintains independent state (distributed aggregation)
- **Note:** This matches real P4 switch behavior

### 3. Packet Value Representation
- **Problem:** Current packets don't have explicit "value" field
- **Solution:** Use payload size initially, add value field if needed

### 4. Route Creation for Aggregated Packets
- **Problem:** Switches need to create routes to destinations
- **Solution:** Add topology helper methods to get routes from switch to host

### 5. Backward Compatibility
- **Problem:** Ensure non-INC traffic still works
- **Solution:** Use default values (0/false) for INC fields, check flags before processing

---

## Files Summary

### Files Requiring Modification

1. **`sim/datacenter/connection_matrix.h`** - Add INC fields to connection struct
2. **`sim/datacenter/connection_matrix.cpp`** - Parse INC semantics
3. **`sim/datacenter/main_eqds.cpp`** - Pass INC metadata to sources/sinks
4. **`sim/eqds.h`** - Add INC metadata storage to EqdsSrc/EqdsSink
5. **`sim/eqds.cpp`** - Pass INC metadata when creating packets
6. **`sim/eqdspacket.h`** - Add INC fields and update newpkt() signature
7. **`sim/datacenter/fat_tree_switch.h`** - Add aggregation state structures and methods
8. **`sim/datacenter/fat_tree_switch.cpp`** - Implement aggregation logic
9. **`sim/datacenter/fat_tree_topology.h`** - Add helper methods (optional)

### New Files to Create

1. **`sim/datacenter/inc_constants.h`** - INC-related enums and constants

### Files That May Need Modification (Future)

1. **`sim/network.h`** - Base packet class (if adding INC to base class)
2. **`sim/compositequeue.h`** - If implementing queue-level aggregation
3. **Logging files** - To track INC aggregation events

---

## Expectation from simulation

1.  Parser successfully loads INC traffic files without errors
2.  Packets contain INC metadata when created from INC connections
3.  Switches detect and process INC packets (agg_dir == UP)
4.  Aggregation state tracked correctly per (fid, rid, cid)
5.  Aggregated packets created when all expected packets arrive
6.  Aggregated packets multicast to all worker destinations
7.  All workers receive same aggregated result
8.  Aggregation values match expected (e.g., SUM correct)

## Next Steps

1. Review and approve this plan
2. Set up development branch
3. Begin with Phase 1 (low-risk data structure changes)
4. Implement incrementally with testing at each phase
5. Validate with `ded_pod_inc.cm` traffic file
6. Document any deviations from plan

---

## References

- Traffic generator: `sim/datacenter/p6_inc/tm_gen/gen_allreduce_inc_ded_pod.py`
- Example traffic file: `sim/datacenter/p6_inc/tm_gen/ded_pod_inc.cm`
- INC flow example: `sim/datacenter/p6_inc/docs/INC_example_flow.md`

